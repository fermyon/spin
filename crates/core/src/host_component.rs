use std::{any::Any, marker::PhantomData, sync::Arc};

use anyhow::Result;

use super::{Data, Linker};

pub trait HostComponent: Send + Sync + 'static {
    /// Host component runtime data.
    type Data: Send + Sized + 'static;

    /// Add this component to the given Linker, using the given runtime state-getting handle.
    // This function signature mirrors those generated by wit-bindgen.
    fn add_to_linker<T: Send>(
        linker: &mut Linker<T>,
        get: impl Fn(&mut Data<T>) -> &mut Self::Data + Send + Sync + Copy + 'static,
    ) -> Result<()>;

    fn build_data(&self) -> Self::Data;
}

impl<HC: HostComponent> HostComponent for Arc<HC> {
    type Data = HC::Data;

    fn add_to_linker<T: Send>(
        linker: &mut Linker<T>,
        get: impl Fn(&mut Data<T>) -> &mut Self::Data + Send + Sync + Copy + 'static,
    ) -> Result<()> {
        HC::add_to_linker(linker, get)
    }

    fn build_data(&self) -> Self::Data {
        (**self).build_data()
    }
}

pub struct HostComponentDataHandle<HC: HostComponent> {
    idx: usize,
    _phantom: PhantomData<fn() -> HC::Data>,
}

impl<HC: HostComponent> Copy for HostComponentDataHandle<HC> {}

impl<HC: HostComponent> Clone for HostComponentDataHandle<HC> {
    fn clone(&self) -> Self {
        Self {
            idx: self.idx,
            _phantom: PhantomData,
        }
    }
}

type DataBuilder = Box<dyn Fn() -> Box<dyn Any + Send> + Send + Sync>;

pub struct HostComponentsBuilder {
    data_builders: Vec<DataBuilder>,
}

impl HostComponentsBuilder {
    pub fn add_host_component<T: Send, HC: HostComponent + 'static>(
        &mut self,
        linker: &mut Linker<T>,
        host_component: HC,
    ) -> Result<HostComponentDataHandle<HC>> {
        let idx = self.data_builders.len();
        self.data_builders
            .push(Box::new(move || Box::new(host_component.build_data())));
        HC::add_to_linker(linker, move |data| {
            data.host_components_data
                .get_or_insert_idx(idx)
                .downcast_mut()
                .unwrap()
        })?;
        Ok(HostComponentDataHandle::<HC> {
            idx,
            _phantom: PhantomData,
        })
    }

    pub fn build(self) -> HostComponents {
        let data_builders = Arc::new(self.data_builders);
        HostComponents { data_builders }
    }
}

pub struct HostComponents {
    data_builders: Arc<Vec<DataBuilder>>,
}

impl HostComponents {
    pub fn builder() -> HostComponentsBuilder {
        HostComponentsBuilder {
            data_builders: Default::default(),
        }
    }

    pub fn new_data(&self) -> HostComponentsData {
        // Fill with `None`
        let data = std::iter::repeat_with(Default::default)
            .take(self.data_builders.len())
            .collect();
        HostComponentsData {
            data,
            data_builders: self.data_builders.clone(),
        }
    }
}

pub struct HostComponentsData {
    data: Vec<Option<Box<dyn Any + Send>>>,
    data_builders: Arc<Vec<DataBuilder>>,
}

impl HostComponentsData {
    pub fn get_or_insert<HC: HostComponent>(
        &mut self,
        handle: HostComponentDataHandle<HC>,
    ) -> &mut HC::Data {
        let x = self.get_or_insert_idx(handle.idx);
        x.downcast_mut().unwrap()
    }

    fn get_or_insert_idx(&mut self, idx: usize) -> &mut Box<dyn Any + Send> {
        self.data[idx].get_or_insert_with(|| self.data_builders[idx]())
    }

    pub fn set<HC: HostComponent>(&mut self, handle: HostComponentDataHandle<HC>, data: HC::Data) {
        self.data[handle.idx] = Some(Box::new(data));
    }
}
